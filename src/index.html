<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logo Collector Snake Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
<!-- Add Poppins font -->
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
<style>
    body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: #333;
        font-family: 'Poppins', sans-serif;
    }
    #game-container {
        border: 2px solid #fff;
    }
</style>
</head>
<body>
    <div id="game-container"></div>

    <script>
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game-container',
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            physics: {
                default: 'arcade',
                arcade: {
                    debug: false
                }
            }
        };

        const game = new Phaser.Game(config);

        let snake;
        let food;
        let badFood;
        let cursors;
        let score = 0;
        let scoreText;
        let gameOverText;
        let restartText;

        function preload() {
            this.load.image('goodLogo', 'assets/00ff00.png');
            this.load.image('badLogo', 'assets/ff0000.png');
            this.load.image('thread', 'assets/0000ff.png');
        }

        function create() {
            snake = new Snake(this, 400, 300);

            food = this.physics.add.group();
            badFood = this.physics.add.group();

            cursors = this.input.keyboard.createCursorKeys();

            // Update text style to use Poppins
            const textStyle = { fontFamily: 'Poppins', fontSize: '32px', fill: '#fff' };
            scoreText = this.add.text(16, 16, 'Score: 0', textStyle);

            gameOverText = this.add.text(400, 300, 'Game Over', { ...textStyle, fontSize: '64px' });
            gameOverText.setOrigin(0.5);
            gameOverText.visible = false;

            restartText = this.add.text(400, 350, 'Tap to Restart', textStyle);
            restartText.setOrigin(0.5);
            restartText.visible = false;

            this.input.on('pointerdown', handleTouch, this);

            spawnFood();
            spawnBadFood();
        }

        function update() {
            if (snake.alive) {
                snake.update(cursors);

                this.physics.overlap(snake.head, food, eatFood, null, this);
                this.physics.overlap(snake.head, badFood, eatBadFood, null, this);

                if (snake.hitSelf()) {
                    gameOver();
                }
            }
        }

        function eatFood(head, food) {
            food.destroy();
            snake.grow();
            score += 10;
            scoreText.setText('Score: ' + score);
            spawnFood();
            spawnBadFood();
        }

        function eatBadFood(head, badFood) {
            gameOver();
        }

        function spawnFood() {
            const x = Phaser.Math.Between(50, 750);
            const y = Phaser.Math.Between(50, 550);
            food.create(x, y, 'goodLogo');
        }

        function spawnBadFood() {
            const x = Phaser.Math.Between(50, 750);
            const y = Phaser.Math.Between(50, 550);
            badFood.create(x, y, 'badLogo');
        }

        function gameOver() {
            snake.alive = false;
            gameOverText.visible = true;
            restartText.visible = true;
        }

        function handleTouch(pointer) {
            if (!snake.alive) {
                restartGame();
            } else {
                const angle = Phaser.Math.Angle.Between(snake.head.x, snake.head.y, pointer.x, pointer.y);
                snake.setDirection(angle);
            }
        }

        function restartGame() {
            score = 0;
            scoreText.setText('Score: 0');
            gameOverText.visible = false;
            restartText.visible = false;
            snake.reset(400, 300);
            food.clear(true, true);
            badFood.clear(true, true);
            spawnFood();
            spawnBadFood();
        }

        class Snake {
            constructor(scene, x, y) {
                this.scene = scene;
                this.body = [];
                this.head = scene.physics.add.image(x, y, 'thread');
                this.head.setDisplaySize(16, 16);
                this.body.push(this.head);
                this.alive = true;
                this.speed = 160;
                this.moveTime = 0;
                this.moveDelay = 100;
                this.tailPosition = new Phaser.Geom.Point(x, y);
                this.direction = new Phaser.Math.Vector2(1, 0);
            }

            update(cursors) {
                if (cursors.left.isDown && this.direction.x !== 1) {
                    this.direction.set(-1, 0);
                } else if (cursors.right.isDown && this.direction.x !== -1) {
                    this.direction.set(1, 0);
                } else if (cursors.up.isDown && this.direction.y !== 1) {
                    this.direction.set(0, -1);
                } else if (cursors.down.isDown && this.direction.y !== -1) {
                    this.direction.set(0, 1);
                }

                if (this.scene.time.now > this.moveTime) {
                    this.move();
                    this.moveTime = this.scene.time.now + this.moveDelay;
                }
            }

            setDirection(angle) {
                this.direction.setToPolar(angle);
                this.direction.normalize();
            }

            move() {
                let x = this.head.x + this.direction.x * 16;
                let y = this.head.y + this.direction.y * 16;

                if (x < 0) x = 800 - 16;
                if (x >= 800) x = 0;
                if (y < 0) y = 600 - 16;
                if (y >= 600) y = 0;

                this.tailPosition.setTo(this.body[this.body.length - 1].x, this.body[this.body.length - 1].y);

                for (let i = this.body.length - 1; i > 0; i--) {
                    this.body[i].x = this.body[i - 1].x;
                    this.body[i].y = this.body[i - 1].y;
                }

                this.head.x = x;
                this.head.y = y;
            }

            grow() {
                const newPart = this.scene.add.image(this.tailPosition.x, this.tailPosition.y, 'thread');
                newPart.setDisplaySize(16, 16);
                this.body.push(newPart);
            }

            hitSelf() {
                return this.body.slice(1).some(part => 
                    Phaser.Math.Within(part.x, this.head.x, 8) && 
                    Phaser.Math.Within(part.y, this.head.y, 8)
                );
            }

            reset(x, y) {
                this.body.forEach((part, index) => {
                    if (index > 0) part.destroy();
                });
                this.body = [this.head];
                this.head.setPosition(x, y);
                this.alive = true;
                this.tailPosition.setTo(x, y);
                this.direction.set(1, 0);
            }
        }
    </script>
</body>
</html>